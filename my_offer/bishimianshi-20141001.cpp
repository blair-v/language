********* 7-13 面向对象相关 ************
[71301] 面向对象的三大基本特征和五项设计原则。
 answ1 ： 封装，继承，多态。 answ2 : (1), 单一职责原则 (2), 开放封闭原则 (3), 替换原则 (4), 依赖倒置原则 (5), 接口隔离原则 
[71302] 什么是深复制，什么是浅复制。(answ:类中有指针成员)。
class A { 
public: 
	A(int _size) : size(_size) {
		data = new int[size];
	}   // 假如其中有一段动态分配的内存 
	A(){}; 
	
	A(const A& _A) : size(_A.size) {
		data = new int[size];
	}  // 深拷贝 
	
	~A() {
		delete []data;
	}  // 析构时释放资源
	
private: 
	int* data; 
	int size;
};
int main() { 
	A a(5), b = a; // 深复制 
}
 answ : 如果对象中没有其他的资源（如：堆，文件，系统资源等），则深拷贝和浅拷贝没有什么区别. 如果有指针成员new，应该自己写 复制构造函数，而不是让编译器自己生成。
[71303] 基类的构造函数/析构函数是否能被派生类继承。answ : 不能！
[71304] 初始化列表和构造函数初始化的区别是什么？ 
         answ : 构造函数初始化 一次是缺省构造函数，另一次是赋值， 需要两个动作。
         answ : 之需要一个动作，调用 构造函数 
[71305] 类的成员变量的初始化顺序是按照声明顺序吗？ 
 (1) 基类的静态变量或全局变量。
 (2) 派生类的静态变量或全局变量。
 (3) 基类成员变量 (基类构造函数)
 (4) 派生类成员变量 (派生类构造函数)
[71306] 当一个类为另一个类的成员变量时，成员初始化列表对其进行初始化  **/
#include <iostream>
#include <cstdio>
using std::cin;
using std::cout;
using std::endl;
class ABC {
public :
    ABC(int x, int y, int z) : a(x), b(y), c(z) {}
private :
    int a, b, c;
};
class MyClass {
public :
    MyClass() : abc(1, 2, 3), k(100) {
        printf("Hello World!\n\nI'm MyClass!\n");
    }
private :
    ABC abc;
    int k;
};
int main() {
    MyClass ma;
    return 0;
}
[71309] C++ 中的空类默认产生哪些成员函数？  answer : 6 个。
. 缺省构造函数。
. 缺省拷贝构造函数。
. 缺省析构函数。
. 缺省赋值运算符。
. 缺省取址运算符。
. 缺省取址运算符 const
[71310] C++ 提供默认参数的函数么？ void fun(int a = 1, int b, int c = 3); fun();
[71311] C++中有哪些情况只能用初始化列表而不能用赋值？
 (1) 当类中含有 const(常量), reference(引用)成员变量时。
 (3) 成员类型是没有默认构造函数的类。
[71402] 什么函数不能声明为虚函数？ answer : static成员函数，内联函数，构造函数。
  如果函数已经被声明为inline, inline 只是提议，具体是编译的时候，编译器说了算的。 
  内联函数已经在编译期间它的调用点上就被展开;而虚拟函数调用的决定则要等到运行时刻runtime在执行程序内部的每个调用点上系统根据被调用对象的实际基类或派生类的类型来决定选择哪一个虚拟函数实例,因此虚拟函数在编译期间并不能被展开,所以内联函数不能成为虚拟函数.
[71403] C++ 如何阻止一个类被实例化？ answ : 抽象类 / private 构造函数。
    举一反三 ：(2) 什么时候编译器会生成默认的复制构造函数 answ : 只要自己没写，程序需要时。
class Shapes {   //抽象类    
protected:
    int x, y;  
public:
    void setvalue(int d, int w=0) { x = d; y = w; }  
    virtual void disp() = 0; //纯虚函数  
};
[71501] 不使用 if / switch 寻找最大值，最小值？
 answ 1 : int max = ((a+b) + abs(a-b)) / 2;
          int min = ((a+b) - abs(a-b)) / 2;
 answ 2 : 对变量的差值进行移位操作，通过是否为非0值确定两个变量的大小。
#include <stdio.h>
int main() {
    int a = 1, b = 4;
    int c = a - b;
    int MAX = (unsigned)c >> (sizeof(int)*8 - 1);
    if(!MAX) printf("%d\n", a);
    else printf("%d\n", b);
}
[71502] 如何实现一个最简单的病毒。 [无限运行的恶意程序]
    while(1) int *p = new int[10000000];
[71505] 已知随即函数 rand7(), 如何构造 rand10() 函数。
int rand7() {
    return rand() % 7 + 1;
}
int rand10() {
    int x = 0;
    do {
        x = (rand7() - 1) * 7 + rand7();
    } while (x > 40);
    return x % 10 + 1;
}
/** 数据库 **/
[80102+]  m_robby - mysql存储引擎
 基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。
 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，
 而InnoDB提供事务支持以及外部键等高级数据库功能。
** 网络与通信 **
[90101] OSI 7层模型和TCP/IP模型是什么。
[90104] 交换机与路由器
 answ:交换机是一种基于 MAC (网卡的硬件地址)识别，能完成封装转发数据包功能的网络设备。它具有流量控制能力，主要用于组建局域网。
[90105] TCP / UDP 的区别有哪些？
 传输层协议主要有TCP和UDP。UDP提供无连接的通信，不能保证数据包被发送到目标地址，
 典型的即时传输少量数据的应用程序通常使用UDP。TCP 是一种面向连接的，可靠的，基于
 字节流的通信协议，它为传输大量数据或为需要接收数据许可的应用程序提供连接定向和可靠的通信。 
 TCP像打电话，UDP发短信。
 TCP与UDP的区别 ：
  (1) TCP 是面向连接的传输控制协议，而UDP提供的是无连接的数据报服务。
  (2) TCP 具有高可靠性，确保传输数据的正确性，不出现丢失或乱序；
      UDP在传输数据前不建立连接，不对数据报进行检查与修改，无需等待对方的应答，
      所以会出现分组丢失，重复，乱序，应用程序需要负责传输可靠性方面的所有工作。
  (3) TCP对系统资源要求较多，UDP对系统资源要求较少。
  (4) UDP具有较好的实时性，工作效率较TCP高。
  (5) UDP的段结构比TCP的段结构简单，因此网络开销也小。
[90106] 可以画出三次握手，四次挥手。
[90107] 什么是 ARP / RARP ？
     ARP ： 位于TCP/IP协议栈的底层协议，用于映射计算机的物理地址与网络IP地址。
     ARP 的工作就是在主机发送帧前，根据 IP地址 获取 MAC地址，以保证通信过程的顺畅。
[90108] Ping 命令是什么？
 ping(packet internet grope, 因特网包探索器)是一个用于测试网络连接量的程序。ICMP 因特网控制报文协议。
 ping www.baidu.com -t -w 3000
 如果ping正确，大体上就可以排除网络访问层，网卡，Modem的输入输出线路，电缆和路由器等存在的故障，从而减小了问题的范围。
[90109] 基本的HTTP流程有哪些？
 HTTP，其主要服务器与浏览器之间的通信。HTTP把客户端浏览器的请求发送到服务器，并把响应的网页内容由服务器返回到客户端浏览器。
[90910] IPv4, IPv6 有什么优点？
 (1), 更大的地址空间。Ipv6 地址长度为128,即有 2^128 - 1 个地址。
 (2), 更小的路由表。 IPv6 的地址分配遵循聚类原则，路由表用一条记录表示一片子网，大大减小路由表的长度，提高了路由器转发数据包的速度。
 (3), 增强的组播支持以及对流的支持。 (加入了对自动配置的支持，这对DHCP的改进和服务质量控制提供了良好的网络平台。)
 (4), 更高的安全性。 (网络层数据加密并对IP报文进行校验)
 
********* 操作系统 ***********
[100101] 进程与线程有什么区别？
 程序 ： 一组指令的有序结合。
 进程 ： 具有一定独立功能的程序关于某个数据集合上的一次运行活动，
        是系统进行资源分配和调度的一个独立单元。
 线程 :  进程的一个实体，是CPU调度和分派的基本单元，是比进程更小的能独立运行的基本单元。
         本身基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如：程序计数器，一组寄存器
          和栈)。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
 总结 ： 一个程序至少有一个进程，一个进程至少有一个线程。
[100102] 线程同步有哪些机制。answ : 临界区, 互斥量, 信号量， 事件。
   (1) 临界区 ： 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
   (2) 互斥量 ： 为协调共同对一个共享资源的单独访问而设计。
   (3) 信号量 ： 为控制一个具有有限数量的用户资源而设计。
   (4) 事 件  ： 用来通知线程有一些事件已发生，从而启动后继任务的开始。
[100103] 内核线程与用户线程的区别。
  根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程。
  内核线程 建立和销毁都是由操作系统负责、通过系统调用完成的，操作系统在调度时，参考各进程内的线程运行情况做出调度决定，如果一个进程中没有就绪态的线程，那么这个进程也不会被调度占用CPU。
  和内核线程相对应的是用户线程，用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
  
  用户线程多见于一些历史悠久的操作系统，例如Unix操作系统，不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少为了在操作系统中加入线程支持，采用了在用户空间增加运行库来实现线程，这些运行库被称为“线程包”，用户线程是不能被操作系统所感知的。
  
  引入用户线程，具体而言，有以下四个方面的优势：
    （1）可以在不支持线程的操作系统中实现。
    （2）创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。
    （3）允许每个进程定制自己的调度算法，线程管理比较灵活。
    （4）线程能够利用的表空间和堆栈空间比内核级线程多。
    
  用户线程的缺点主要有以下两点：
    （1）同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。
    （2）页面失效也会产生类似的问题。
  内核线程的优缺点刚好跟用户线程相反。实际上，操作系统可以使用混合的方式来实现线程。
  
 *** 10-2 内存管理 ***
[100201] 内存管理有哪几种方式？
 常见的 ： 块式管理， 页式管理， 段式管理 和 段页式管理。
  (1) 块式管理 ： 把主存分为一大块一大块的，当所需的程序片断不在主存时就分配一块主存空间。
           把程序片断load入主存，就算所需的程序片段只有几个字节也只能把这一块分配给它。
           这样会造成更大的浪费，平均浪费了50%的内存空间，但是易于管理。
  (2) 页式管理 ： 把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法
           的空间利用率要比块式管理高得多。
  (3) 段式管理 ： 把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在
           空间利用率上又比页式管理高很多，但是缺点是 ： 一个程序片断可能会被分为几十段，
           这样很多时间就会被浪费在计算每一段的物理地址上。
  (4) 段页式管理 ： 结合了段式管理和页式管理的优点。把主存先分成若干段，每一段又分为若干页。
           段页式管理每取一数据，要访问3次内存。
[100202] 分段和分页的区别是什么？
  页和分段系统有许多相似之处，但在概念上两者完全不同，主要表现在： 
  1、页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。 
段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。 
  2、页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。 
段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。 
  3、分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。 
分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
[100203] 什么是虚拟内存？
  虚拟内存是计算机系统内存管理的一种技术。
  它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，
  它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换
  (1) 扩大地址空间。
    无论段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大。
  (2) 内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。
  (3) 公平分配内存。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。
  (4) 当进程需要通信时，可采用虚存共享的方式实现。
 使用虚存是有代价的，主要表现在以下几个方面 ：
  (1) 虚存的管理需要建立很多的数据结构，这些数据结构要占用额外的内存。
  (2) 虚拟地址到物理地址的转换，增加了指令的执行时间。
  (3) 页面的换入换出需要磁盘I/O，这是很耗时间的。
  (4) 如果一页中只有一部分数据，会浪费内存。

[100204] 什么是内存碎片？什么是内碎片？什么是外碎片？
    内存碎片 是由于多次进行内存分配造成的，当进行内存分配时，内存格式一般为 ： 
 (用户使用段)(空白段)(用户使用段)，当空白段很小的时候可能不能提供给用户足够需要的空间，
 可能夹在中间的空白段的大小为5,而用户需要的内存大小6,这样会产生很多的间隙造成使用效率
 的下降，这些很小的空隙叫碎片。
     内碎片 ： 分配给程序的存储空间没有用完，有一部分是程序不使用，但其他程序也没法用的空间。
 内碎片是处在区域内部或页面内部的存储块，占用这些区域或页面的进程并不使用这个存储块，
 而在进程占用这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用
 这个存储块。
    外碎片 ： 由于空间太小，小到无法给任何程序分配(不属于任何进程)的存储空间。
 外部碎片是出于任何已分配区域或页面外部的空闲存储块，这些存储块的总和可以满足当前申请的
 长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。
    内碎片和外碎片是一对矛盾体，一种特定的内存分配算法，很难同时解决好内
 碎片和外碎片的问题，只能根据应用特点进行取舍。
[100205] 虚拟地址，逻辑地址，线性地址，物理地址有什么区别？
[100206] Cache 替换算法有哪些？
 (1) 随机算法  (2) 先进先出 (FIFO) 算法  (3) 近期最少使用 (LRU) 算法
 *** 10-3 用户编程接口 ***
[100301] 库函数与系统调用有什么不同？
 库函数调用是语言或应用程序的一部分，它是高层的，完全运行在用户空间，
  为程序员提供调用真正的在幕后完成实际事务的系统调用接口。
  而系统函数是内核提供给应用程序的接口，属于系统的一部分。
 库函数调用通常比行内展开的代码慢，因为它需要付出函数调用的开销。但系统调用比库函数
 调用还要慢很多，因为它需要把上下文环境切换到内核模式。
[100302] 静态链接与动态链接有什么区别？
 静态链接 ： 指把要调用的函数或者过程直接链接到可执行文件中，成为可执行文件的一部分。
            换句话说，函数和过程的代码就在程序的exe文件中，该文件包含了运行时所需
            的全部代码。静态链接的缺点是当多个程序都调用相同的函数时，内存就会存在
            这个函数的多个拷贝，这样就浪费了内存资源。
 动态链接 ： 仅仅是在可执行文件中所调用函数的描述信息(往往是一些重定位信息)仅当应用
            程序被装入内存开始运行时，在OS管理下，才在应用程序与相应的DLL之间建立链接
            关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，OS才转去执行
            DLL 相应的函数代码。
[100303] 静态链接库与动态链接库有什么区别？
 静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中
    的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含
    在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。
 静态链接库和动态链接库的另外一个区别 ：
    静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的
    动态或静态链接库。静态链接库与静态链接库调用规则总体比较如下。
 对于静态链接库(比较简单)：
    首先，静态链接库的使用需要库的开发者提供生成库的.h头文件和.lib文件。
生成库的.h头文件中的声明格式如下：
  extern "C" 函数返回类型 函数名(参数表);
    在调用程序的.cpp源代码文件中如下：
#include "..\lib.h"
#pragma comment(lib,"..\\debug\\libTest.lib")
//指定与静态库一起链接
第二，因为静态链接库是将全部指令都包含入调用程序生成的EXE文件中。
     因此如果用的是静态链接库，那么也就不存在“导出某个函数提供给用户使用”的情况，
     要想用就得全要！要不就都别要！:)
  对于动态链接库：
    动态链接库的使用需要库的开发者提供生成的.lib文件和.dll文件。或者只提供dll文件。
首先我们必须先注意到DLL内的函数分为两种：
(1)DLL 导出函数，可供应用程序调用；
(2)DLL 内部函数，只能在 DLL 程序使用，应用程序无法调用它们。
 因此调用程序若想调用DLL中的某个函数就要以某种形式或方式指明它到底想调用哪一个函数。

[100304] 用户态和核心态有什么区别？
 核心态与用户态是操作系统的两种运行级别，它用于区分不同程序的不同权利。核心态就是
  拥有资源多的状态，或者说访问资源多的状态，也称之为特权态。用户态就是非特权态。
  在非特权态访问的资源将受到限制。如果一个程序运行在用户态，则其需求的资源将受到
  各种限制。例如：如果要访问OS的内核数据结构，如进程表，则需要在特权态下才能办到。
  如果要访问用户程序里的数据，则在用户态就可以了！
[100305] 用户栈与内核栈有什么区别？
 内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。
  每个进程会有两个栈，一个用户栈，存在于用户空间；
                     一个内核栈，存在与内核空间；
  当进程在用户空间运行时，CPU堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈。
  当进程在内核空间时，CPU堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。
 ---------进程用户栈和内核栈之间的切换--------
  当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。
   系统调用实质就是通过指令产生中断，称为软中断。进程因为中断（软中断或硬件产生中断），
   使得CPU切换到特权工作模式(0最高为内核模式，3最低为用户模式)，此时进程陷入内核态，
   进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中，然后设置堆栈指针寄存器的地址
   为内核栈地址，这样就完成了用户栈向内核栈的切换。
  当进程从内核态切换到用户态时，最后把保存在内核栈中的用户栈地址恢复到CPU栈指针寄存器即可，
   这样就完成了内核栈向用户栈的切换。
  ------------------------------------
 这里要理解一下内核堆栈。前面我们讲到，进程从用户态进入内核态时，需要在内核栈中保存用户栈
  的地址。那么进入内核态时，从哪里获得内核栈的栈指针呢？
   要解决这个问题，先要理解从用户态刚切换到内核态以后，进程的内核栈总是空的。
   这点很好理解，当进程在用户空间运行时，使用的是用户栈；当进程在内核态运行时，
   内核栈中保存进程在内核态运行的相关信息，但是当进程完成了内核态的运行，重新回到用户态时，
   此时内核栈中保存的信息全部恢 复，也就是说，进程在内核态中的代码执行完成回到用户态时，
   内核栈是空的。
 理解了从用户态刚切换到内核态以后，进程的内核栈总是空的，那刚才这个问题就很好理解了，
  因为内核栈是空的，那当进程从用户态切换到内核态后，把内核栈的栈顶地址设置给CPU的
  栈指针寄存器就可以了。
** 第 12 章 发散思维 **
12-1 设计模式
 常见的有 ： 工厂模式，单件模式，适配器模式，享元模式， 观察者模式。
m_0203 你平时读的专业书籍,关注的技术网站有哪些？
 “好马配好鞍” “好鞍配好马”
 C语言:《C专家编程》《C和指针》《C Primer Plus》《The C programming language》《C陷阱..》
 C++ : 《C++程序设计语言》《C++ Primer》《C++标准程序库》《C++语言的设计和演化》
       《深度搜索C++对象模型》《Essential C++中文版》《Effective C++中文版》
       《More Effective C++ 中文版》《C++编程思想》《C++ Primer Plus》
 算法 ：《算法导论》《算法艺术与信息学》《编程之美》
 OS   ：《深入理解计算机系统结构》《Linux内核设计与实现》《GNU/Linux编程指南》
        《Linux内核完全注释》《Linux内核分析及编程》
网络编程：《TCP/IP详解3卷本》《UNIX网络编程》
编译原理：《编译原理》(Alfred V.Aho等著)《编译原理基础》(刘坚著)
软件工程：《设计模式--可复用面向对象软件的基础》《大话设计模式》《重构-改善既有代码的设计》
著名的技术网站 ： CSDN, 51CTO, chinaunix, cnblogs等。
          国外 ： stackoverflow.com, cplusplus.com, codeproject.com
**  第 13 章 数据结构与算法  **
 *** 数组 ***
m_0101 如何用递归实现数组求和。
m_0102 用 for 循环打印出一个二维数组。
m_0103 如何用递归判断一个数组是否是递增。
 bool f(int a[], int n) {
    if (n == 1) return true;
    return (a[n-1] > a[n-2]) && f(a, n-1);
 }
m_0105 如何分别使用递归与非递归实现二分查找算法。
int bina(int *a, int len, int data) {
    if (a == NULL || len <= 0) return -1;
    int l = 0, r = len - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (a[mid] > data) return l = mid + 1;
        else if (data < a[mid]) {
            r = mid - 1;
        }
        else return mid;
    }
    return -1;
 } 递归的自己想(略) l, r.
m_0107 如何计算两个有序整型数组的交集
    a = 0, 1, 2, 3, 4
    b = 1, 3, 5, 7, 9
answ1 : 二路归并 [仔细]
answ2 : 先遍历一数组，将遍历得到的元素存放到哈希表，然后遍历另外一个数组，同时对建立的哈希表进行查询，如果存在，则为两者的交集元素。
情况二 ：如果两个数组的长度，相差悬殊的话，那么先遍历小的数组，然后挨个在大的上二分。
m_0108 如何找出数组中重复次数最多的数？
 answ1 : 空间换时间。(一般不采用)
 answ2 : 使用 map 映射表。 map<int, int> m; for( ) { if(++m[a[i]] >= m[val]) val = a[i];}
m_0109 O(n) 找出数组中出现次数超过一半的数字。
answ1 : 每次取出两个不同的数字. 时间O(n) 空间O(1)
answ2 : Hash 法, hash_map 遍历数组，并用两个值存储目前出现次数最多的数和对应出现的次数时空借O(n)。
m_0110 如何找出数组中唯一的重复元素。 1 ~ N-1 存放在 a[N] 中。
 answ1 : 异或法。 answ2 : 位图法。
 变形题 ： 取值为 [1, n-1] 含 n 个元素的整数数组，至少存在一个重复数，找出任意一个重复数。
  answ1 : 位图法。时间 O(n), 空间 O(n)
  answ2 : 数组排序法。 也就是 hash 计数。
  answ3 : Hash法，数组如果是有符号数 int 型，则本方法可行。将数组元素的值作为索引，对于元素 a[i]
          如果 a[a[i]]>0, 则设置 a[a[i]] = -a[a[i]]; 如果 a[a[i]]<0,说明a[a[i]] 是一个重复数。
遍历两个数组长度相差悬殊的情况，如数组 a 的长度远远大于数组 b 的长度
m_0111 如何判断一个数组中的数值是否连续相邻?
 如果没有 0 的存在，要组成连续的数列，最大值和最小值的差距必须是4,存在0的情况下，只要最大小值差距下于4就哦！
m_0113 如何找出数列中符合条件的数对的个数。
 answ1 : 排序 +二分
 answ2 : 计数排序，将 1 ~ N 个数放在一块很大的空间里面，比如 1 放在 1号位，...
m_0114 如何寻找出数列中缺失的数。 problem : 数组 a 有 n 个元素，元素的取值范围是 1 ~ n
 answ1 : 排序相邻，时间 O(nlogn), 空间 O(1)
 answ2 : 使用 bitmap 方法。 时间 O(n), 空间 O(n)
 answ3 : 遍历数组，假设第 i 个位置的数字为 j, 则通过交换将 j 换到下标为 j 的位置上。时O(n),空间O(1)
m_0117 如何把一个整型数组中重复的数字去掉。
 answ : 快速排序首先，然后变为 1 1 1 2 2 3, 遍历该数组，k = 0, i = 1; 
 for () { if (a[k] != a[i]) { a[k+1] = a[i];k++; } }
m_0118 如何找出数组中第二大的数？
 answ1 : 用两个变量，一个记录最大的数，一个记录第二大的数字。遍历数组，1)更新最大，更新第二大2)检查更新二大
m_0121 如何计算出序列的前 n 项数据
 for(k = 0; k < N; k++) { tmpA = a*i; tmpB = b*j; if(tmpA <= tmpB) {Q[k] = tmpA; i++;} else }
m_0123 如何判断一个整数 x 是否可以表示成 n (n>=2) 个连续正整数的和。
 x = m + (m+1) + (m+2) + ... + (m+n-1), 推出 ： m = (2*x/n - n + 1) / 2; m >= 1;
 也就是判断 (2*x/n - n + 1) 是不是偶数的问题。 tmp = m; if(tmp == (int)tmp) 就 OK！
****** 链表 ******
m_0210 如何实现单链表交换任意两个元素(不包括表头)
struct Node {
    int value;
    Node* next;
};
Node* findPre(Node* head, Node* p) {
    Node* q = head;
    while(q) {
        if(q->next == p)
            return q;
        else q = q->next;
    }
    return NULL;
}
Node* swap(Node* head, Node* p, Node* q) {
    if(head == NULL || p == NULL || q == NULL) { return NULL; }
    if(p == q) return head;
    if(p->next == q) {
        Node* pre_p = findPre(head, p);
        pre_p->next = q;
        p->next = q->next;
        q->next = p;
    }
    else if(q->next == p) {
        Node* pre_q = findPre(head, q);
        pre_q->next = p;
        q->next = p->next;
        p->next = q;
    }
    else if(p != q) {
        Node* pre_p = findPre(head, p);
        Node* pre_q = findPre(head, q);
        Node* after_p = p->next;
        q->next = after_p;
        pre_p->next = q;
        pre_q->next = p;
    }
    return head;
}
m_0211 如何检测一个较大的单链表是否存在环。
 answ1 : fast, slow;
 answ2 : STL 中的 map<Node*, int>
m_0213 如何删除单链表中的重复节点
 answ : hash_map
****** 字符串 ******
m_0302 如何将字符串逆序
m_0605 非递归求二叉树的深度
struct Node {
    int value;
    Node* par;
    Node* lchild;
    Node* rchild;
};
int dep(Node* root) {
    if(root == NULL) return 0;
    return max(dep(root->lchild), dep(root->rchild)) + 1;
}
int fdep(Node* root) {
    deque<Node*> dq;
    int high = -1;
    while(1) {
        for(; root != NULL; root = root->lchild) {
            dq.push_back(root);
        }
        high = max(high, (int)dq.size());
        while(1) {
            if(dq.empty()) return high;
            Node* par = dq.back();
            Node* rchild = par->rchild;
            if(rchild && root != rchild) {
                root = rchild;
                break;
            }
            root = par;
            dq.pop_back();
        }
    }
    return high;
}
m_0606 如何判断两颗二叉树是否相等。
 A, B 两棵树相等，当且仅当 rootA->c == rootB->c; 而且A,B左右子树相等。我觉得是这样！
******** 第 14 章 海量数据处理 ********     
14-1 基本方法
  针对海量数据 ： Hash法，Bit-map法， Bloom filter法， 数据库优化法，倒排索引法，外排序法，Trie法，堆，双层桶法以及MapReduce法。
m_0301 topK 问题
topK : 分治 + Trie, 树/hash + 小项堆， 即先将数据集按照Hash方法分解成多个小数据集，
 然后使用Trie树或者Hash统计每个小数据集中出现频率最高的前K个数 ，最后在所有 topK 中求出最终的 top K.
例如 ： 有 1 亿个浮点数，如何找出其中最大的 10000 个？ [一亿个float 400M， 内存小的计算机排不了！]
 answ1 : 局部淘汰法  用一个容器保存前 10000 个数，然后将剩余的所有数字一一与容器内的最小数字相比。
 answ2 : 分治法  1 亿 = 100 个 100万。  100W 查找 10000 用类似快排的分治法。
 answ3 : 先 hash 去重。然后通过 分治法 或 最小堆法 查找最大的 10000 个数。
 answ4 : 最小堆。首先读入 1W 个数来创建大小为 1W 的小项堆。建堆的时间复杂度为 O(logm)
下面针对不同的应用场景分析 ： 1) 单机器，单核，足够大内存 2) 单机，多核，足够大内存 3) 单机，单核，受限内存 4) 多机，受限内存
MapReduce 是云计算的核心技术之一，是一种简化并行计算的分布式编程模型。
07,程序设计基础*************************************************************
[701],static 变量有什么作用？
 static(全局/局部)只初始化一次，static()函数与普通函数的区别只在一个源文件中有效。
 C++中，类内static成员 ：
  (1): 是类成员
  (2): 存储在全局数据区
  (3): 遵从 public, protected, private访问规则。
  (4): static成员变量的初始化在类外. 
        private,protected的static成员虽然可以在类外初始化，但是不能在类外访问。
   与全局变量相比的优势 『
    (1): 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性。
    (2): 可以实现信息隐蔽。(private)
  静态数据成员有以下 :
   static成员函数是类的内部实现，属于类定义的一部分。
    \普通的成员函数一般都隐含了一个this指针，
    this指针指向类的对象本身。static成员函数没有this指针，无法访问类对象的非静态成员。
 auto自动变量存放在栈区，存放在静态区的变量生命周期比较长。
 引申 ： 不推荐在头文件中定义任何变量。
[702],const有哪些作用？
 1,不可变性 2, 进行类型检查 3, 不变则已，一变都变 4,保护被修饰量 
 5,为函数重载 6,节省空间 const int pi=3;int i = p1;
 引申 ： 什么情况下需要使用const关键字？
  (1) 修饰一般常量 (2) 修饰常数组 (3) 修饰常对象 (4) 修饰常指针
  (5) 修饰常引用 【所引用的对象不能被更新】
  (6) 修饰函数的常参数void f(const int var) 告诉gcc-var在函数中不可变
  (7) 修饰函数的返回值 (8) 修饰类的成员函数 int f() const; 
  (9) 在另一连接文件中引用const常量。extern const int i(=10);
[703] volatile 在程序设计中有什么作用？
 volatile用来修饰被不同线程访问和修改的变量。从内存中提取，
  而不会利用cache中原有数值。系统对这种变量的处理不会被优化。
 (提高存取速度-编译器优化-volatile不优化)
[704] 断言ASSERT()是什么?
 ASSERT()捕获的是非法情况，而不是错误情况。
  用法 ：ASSERT(n != 0);
         k = 10 / n;
 ASSERT()只在Debug版本中有，编译的Release版本则被忽略。
 ASSERT()是宏，而assert()是ANSIC规定的函数
 assert()的缺点是，频繁的调用会极大的影响程序的性能。在调试结束后可以-
#include <cstdio>
#define NDEBUG
#include <cassert>
int main() {
    int k = 2;
    assert(k != 0);
    printf("%d\n", 100/k);
    return 0;
}
[705] C99,允许main()函数没有参数，或者有两个参数。
 int main(int argc, char *argv[])命令行参数有时用来启动一个程序的执行.
 argc参数表示命令行参数的个数。argv[0]是文件名，第一个参数。
[706] C++里面是不是所有的动作都是main()函数引起的
 只是编译器是由main()开始执行的，main()只不过是一个约定的函数入口，
 在main()的显示代码执行之前，会调用一个由编译器生成的_main()函数，而_main
 会进行所有全局对象的构造及初始化工作。++优先级 > *操作符
[707] 前置运算符与后置运算符有什么区别?
 var : a
 ++a 表示取a的地址，增加它的内容，然后把值放在寄存器中；
 a++ 表示取a的地址，把值装入寄存器，然后增加内存中a的值。
 引申 ： (1) i++ = 5; (2) ++i = 5;
   第一种写法是错误的。i++的运算结果不是i变量的引用，而是一个临
    时变量，编译器也不允许对一个临时变量重新赋值。
[708] 如何进行 float, bool, int, 指针变量与 “零值” 的比较
 answ : (1) int 类型
            if(n == 0)  if(n != 0)
        (2) flaot 类型
            const float NORM = 1e-6;
            if((x >= -NORM) && (x <= NORM))
            const double EPS = 1E-12;
            const double inf = 1E+12;
        (3) bool 类型
           if(flag)  if(!flag)
        (4) 指针类型
           if(p == NULL)  if(p != NULL)
[709] new/delete 与 malloc/free 的区别是什么？
 malloc/free 是C/C++语言的标准库函数。new/delete 是 C++ 的运算符。
  对于类的对象而言，malloc/free无法满足动态对象的要求。
  malloc/free不在编译器的控制权限之内，无法执行构造函数与析构函数。
 它们的主要区别 ：
  (1) new 能够自动计算需要分配的内存空间。
  (2) new/delete 直接带具体类型的指针
  (3) new 是类型安全的。int* p = new float[2];（X）
  (4) new 由两步构成，分别是 new 操作和构造。
        new 操作对应于malloc,但new操作可以重载，可以自定义内存分配策略。
  (5) new将调用构造函数，而malloc不能。delete/free同理。
  (6) new/delete 不需要库文件支持。
[710] C语言中，int型变量 < 0,是否可知 2*x < 0;
[711] exit(status)是否跟从main()函数返回的status等价
  在 C 语言标准中，它们是等价的，但是如果在退出的时候需要使用main()的局部数据，return()就不行了！
 return : 返回函数调用，如果返回的是main()函数，则退出程序。
 exit   : 在调用处强行退出程序。exit(0)正常退出，0给系统，
            exit(1)内存分配失败，1给系统。exit(2)打开文件失败！
[713] 在 C++ 中如何实现模板函数的外部调用
 export 是 C++ 新增的关键字，它的作用是实现模板函数的外部调用，类似于 extern 关键字。
 为了访问其他代码文件中的变量或对象，对普通类型可以利用 extern 来使用这些变量或对象。
 对于模板类型，则可以在头文件中声明模板类和模板函数，在代码文件中使用 export 来定义具体
 的模板类对象和模板函数，然后在其他用户代码文件中，包含声明头文件后，就可以使用这些对象和函数了。
 extern int n;
 extern struct Point p;
 extern class A a;
 export template <class T> class Stack<int> s;
 export template <class T> void f(T& t) {...}
[714] C++中，explicit 有什么用？ String s1 = "hello"; 阻止隐式转换。
[715] C++中异常的处理方法以及使用了哪些关键字 ： try, catch, throw. [finally]
[7.2] 内存分配  由于内存分配不当引起的堆栈溢出，缓冲区溢出等问题。常会导致系统瘫痪。
[721] 内存分配的形式有哪些？
 C/C++ 编译的程序所占用的系统内存一般分为以下几个部分的内容 :
  (1) BSS段(由符号起始的区块段) : 存放未初始化的全局数据和静态数据的一块内存区域。[属于静态内存分配]
  (2) 数据段 ： 已初始化全局变量的一块内存区域。[属于静态内存分配]
  (3) 代码段 ： 文本段。用来存放程序执行代码(包括成员函数，全局函数，以及其他函数)的一块内存区域。
  (4) 堆heap : 用来存放进程运行中被动态分配的内存段。
  (5) 栈stack : 用户存放程序临时创建的局部变量。
[722] 内存泄露？ answ : 一般指堆内存泄露。扩：频繁的malloc/free会有内存碎片！
       泄露： 由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。
[723] 栈空间的最大值是多少？
 win : 2M. 堆：一般<=2G  堆是向高地址扩展的数据结构，是不连续的内存区域！
     系统是用链表来存储空闲内存地址的。堆的大小受限于计算机有效的虚拟内存。
 Linux :默认栈 8M. ulimit -s可设置。
[724] 什么是缓冲区溢出？
aw:缓冲区是程序运行的时候机器内存中的一个连续块，它保存了给定类型的数据，随着动态分配变量会出现问题。
 发生溢出的数据覆盖在合法数据(数据，下一条指令的指针，函数返回地址等)上的情况。
other : 认为缓冲区溢出等。缓冲区溢出是目前导致“黑客”型病毒横行的主要原因。
      红色代码，Slammer,"冲击波"都是利用缓冲区溢出漏洞的典型。
[725] 结构体内存对齐。
 编译器为结构的每个成员按其自然边界分配空间。
  字节对齐的作用不仅仅是便于CPU的快速访问，使CPU的性能达到最佳。
  合理的利用字节对齐可以有效地节省存储空间。
[726] C/C++ 头文件中的 ifndef/define/endif 的作用有哪些？
 http://blog.csdn.net/robby_chan/article/details/8972931   可能会产生大量的声明冲突。
[727] <filename.h>与"filename.h"
[728] 含参数的宏与函数的区别
 (1) 函数调用是在程序运行时处理的，它需要分配临时的内存单元；
      而宏展开则在编译时进行，不进行分配内存单元也不进行值的传递处理。
 (2) 函数的形参和实参都要定义类型，宏名无类型。
[730] 宏定义与内联函数的区别
 answ : 宏代码，预处理器用复制代码的方式代替函数调用，省去了参数压栈，
     生成汇编语言的CALL调用，返回参数，执行return等过程。从而提高了速度。
    内联函数是代码被插入到调用者代码处的函数。对于C++语言中 ：
    内联函数的使用有所限制，它只适合函数体代码简单的函数使用，
    不能包含复杂的控制结构语句(如：while,switch),
    并且内联函数本身不能直接调用递归函数。
  1)， 宏定义是在预处理阶段进行代码替换，"内联函数是在编译阶段插入代码"
  2),  宏定义没有类型检查，而内联函数有类型检查。
 引申 ： 内联函数与普通函数的区别有哪些？
  内联函数的参数传递机制与普通函数相同。但是编译器会在每处调用内联函数的
  地方将内联函数的内容展开，这样避免了函数调用的开销又没有宏机制的缺陷。
 它 ： 如果函数体过大编译器会放弃内联方式。
[731] C与C++中的struct的区别是什么？ / C+中struct与class区别
 (1) C语言的 struct 不能有函数成员，而C++的 struct 可以有。
 (2) C++ 的 struct 的成员有访问权限的设定。
 (3) C语言的 struct 是没有继承关系的，而 C++ 的 struct 却有丰富的继承关系。
 C 语言的 struct 是用户自定义类型，C++ 的 struct 是抽象数据类型。
 C++ 在用模板的时候只能写 template <class Type> 或 template <typename Type> 不能写 template <struct Type>.
 / C++中struct与class区别。
 举一反三 ： 利用位运算计算数的绝对值  int y = x >> 31;  return (x^y)-y; 
            负数右移31位变为0xfffffff.
加难 ： 如何只用逻辑运算实现"乘法运算"？
  1011 * 1010
 1011*1000 + 1011*0010
int multiply(int a, int b) {
    bool neg = (b < 0);
    if(b < 0) b = -b;
    int sum = 0;
    map<int, int> bit_map;
    for(int i = 0; i < 32; ++i) {
        bit_map.insert(pair<int, int> (1<<i, i));
    }
    while(b > 0) {
        int last_bit = bit_map[b&~(b-1)];
        sum += (a << last_bit);
        b &= b-1;
    }
    if(neg) sum = -sum;
    return sum;
}
如何只用逻辑运算实现"除法运算"？
 100/7  --  1*7, 2*7, 4*7, 8*7
while (left_num >= y) {
    int multi = 1;
    while (y*multi <= (left_num>>1)) {
        multi = multi << 1;
    }
    result += multi;
    left_num -= y*multi;
}
return result;
[733] 如何求解整型数的二进制表示中 1 的个数
while (x) {
    count++;
    x = x&(x-1);
}
[734] n 位二进制数，有多少个数中不存在两个相邻的 1
 a[n] = a[n-1]+a[n-2]; n <=40(一定不会超)
[7801] 函数指针与指针函数 / 数组指针与指针数组 / 函数模板与模板函数
      类模板与模板类 / 指针常量与常量指针...
   (1)
    int* func(int x)  指针函数 是 函数
    int (*f)(int x)   函数指针 是 指针
    f = func; 将 func 函数的首地址赋值给指针 函数指针
[7802] 默认构造函数是否可以调用单参数的构造函数？
 answ : 不可以！
  因为在默认构造函数内部调用带参的构造函数属用户行为而非编译器行为，它只
  执行函数调用，而不会执行其后的初始化表达式。只有在生成对象时，初始化
  表达式才会随相应的构造函数一起调用。
[7803] C++ 中函数调用有哪几种方式？
  http://blog.csdn.net/robby_chan/article/details/9071451
  编译器一般使用堆栈实现函数调用。堆栈是存储器的一个区域。
  windows 为每个线程自动维护一个堆栈，堆栈的大小可以设置。
  编译器使用堆栈来存放每个函数的参数，局部变量等信息。
      由于函数调用经常会被嵌套，在同一时刻，堆栈中会存储多个函数的信息，
  每个函数又占用一个连续的区域，一个函数占用的区域常被称为帧，编译器是
  从高地址开始使用堆栈。切换线程的一个重要的工作，就是将堆栈指针设为当前
  线程的一个重要工作，就是将堆栈指针设为当前线程的堆栈堆顶地址。不同CPU，
  不同编译器的堆栈布局，函数调用方法都可能不同，但堆栈的基本概念是一样的。
      当一个函数被调用时，进程内核对象为其在进程的地址空间的堆栈部分分配
  一定的栈内存，给该函数使用，函数堆栈用于 ：
   (1), 在进入函数之前，保存“返回地址”和环境变量。返回地址是指该函数结束后，
        从进入该函数之前的那个地址继续执行下去。
   (2), 在进入函数之前，保存实参或实参复制，局部变量。
   函数原型 ： [连接规范] 函数类型 [调用约定] 函数名 参数列表 {......}
   调用约定 ： 调用约定是决定函数实参或实参复制进入和退出函数堆栈的方式以及
               函数堆栈释放的方式。
我们知道，调用函数时，计算机常用栈来存放函数执行需要的参数，由于栈的空间大小是有限的，在windows下栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，windows下栈的大小是2M（也有的说是1M），如果申请的空间超过栈的剩余空间时，将提示overflow。
在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
在参数传递中，有两个重要的问题必须要明确说明：
1. 当参数个数多于一个时，按照什么顺序把参数压入堆栈；
2. 函数调用后，由谁来把堆栈恢复原状。
在高级语言中，就是通过函数的调用方式来说明这两个问题的。常见的调用方式有：
stdcall
cdecl
fastcall
thiscall
thiscall
naked call
下面就分别介绍这几种调用方式：
1. stdcall
stdcall调用方式又被称为Pascal调用方式。在Microsoft C++系列的C/C++编译器中，使用PASCAL宏，WINAPI宏和CALLBACK宏来指定函数的调用方式为stdcall。
stdcall调用方式的函数声明为：
int _stdcall function(int a, int b);
stdcall的调用方式意味着：
（1） 参数从右向左依次压入堆栈
（2） 由被调用函数自己来恢复堆栈
（3） 函数名自动加前导下划线，后面紧跟着一个@,其后紧跟着参数的尺寸
上面那个函数翻译成汇编语言将变成：
push b 先压入第二个参数
push a 再压入第一个参数
call function 调用函数
在编译时，此函数的名字被翻译为_function@8
2. cdecl
cdecl调用方式又称为C调用方式，是C语言缺省的调用方式，它的语法为：
int function(int a, int b) // 不加修饰符就是C调用方式
int _cdecl function(int a, int b) // 明确指定用C调用方式
cdecl的调用方式决定了：
（1） 参数从右向左依次压入堆栈
（2） 由调用者恢复堆栈
（3） 函数名自动加前导下划线
由于是由调用者来恢复堆栈，因此C调用方式允许函数的参数个数是不固定的，这是C语言的一大特色。
此方式的函数被翻译为：
push b // 先压入第二个参数
push a // 在压入第一个参数
call funtion // 调用函数
add esp, 8 // 清理堆栈 。。。。。需要熟悉一下esp寄存器的功能，建议看一下汇编有关的书，基本都有讲
在编译时，此方式的函数被翻译成：_function
3. fastcall
fastcall 按照名字上理解就可以知道，它是一种快速调用方式。此方式的函数的第一个和第二个DWORD参数通过ecx和edx传递，
后面的参数从右向左的顺序压入栈。
被调用函数清理堆栈。
函数名修个规则同stdcall
其声明语法为：
int fastcall function(int a, int b);
4. thiscall
thiscall 调用方式是唯一一种不能显示指定的修饰符。它是c++类成员函数缺省的调用方式。由于成员函数调用还有一个this指针，因此必须用这种特殊的调用方式。
thiscall调用方式意味着：
参数从右向左压入栈。
如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压入栈后被压入栈。
参数个数不定的，由调用者清理堆栈，否则由函数自己清理堆栈。
可以看到，对于参数个数固定的情况，它类似于stdcall，不定时则类似于cdecl。
5. naked call
是一种比较少见的调用方式，一般高级程序设计语言中不常见。
函数的声明调用方式和实际调用方式必须一致，必然编译器会产生混乱。
函数名字修改规则：
1. C编译时函数名修饰约定规则：
__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为_function@8。
__cdecl调用约定仅在输出函数名前加上一个下划线前缀，格式为_function。
__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为@function@8。
它们均不改变输出函数名中的字符大小写，这和PASCAL调用约定不同，PASCAL约定输出的函数名无任何修饰且全部大写。
2. C++编译时函数名修饰约定规则：
__stdcall调用约定：
（1）以“?”标识函数名的开始，后跟函数名；
（2）函数名后面以“@@YG”标识参数表的开始，后跟参数表；
（3）参数表以代号表示：
X--void ，
D--char，
E--unsigned char，
F--short，
H--int，
I--unsigned int，
J--long，
K--unsigned long，
M--float，
N--double，
_N--bool，
....
PA--表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代
表一次重复；
（4）参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型,指针标识在其所指数据类型前；
（5）参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。
其格式为“?functionname@@YG*****@Z”或“?functionname@@YG*XZ”，例如
int Test1（char *var1,unsigned long）-----“?Test1@@YGHPADK@Z”
void Test2（） -----“?Test2@@YGXXZ”
__cdecl调用约定：
规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YA”。
__fastcall调用约定：
规则同上面的_stdcall调用约定，只是参数表的开始标识由上面的“@@YG”变为“@@YI”。
VC++对函数的省缺声明是"__cedcl",将只能被C/C++调用。
[7804] 什么是可重入函数？ C语言中如何写可重入函数
 可重入函数是指能够被多个线程“同时”调用的函数，并且能保证函数结果正确性的函数。
 在 C 语言中编写可重入函数时，尽量不要使用全局变量或静态变量，如果使用了全局
 变量或静态变量，就需要特别注意对这类变量访问的互斥。
  保证函数可重入性的措施 『
   1, 信号量机制  2, 关调度机制  3, 关中断机制等方式。 』
[7901] 不使用流程控制语句，打印 1 ~ 1000的整数。
方法1 : 类中构造函数和static成员变量的结合。
struct Print {
    static int a;
    Print() {
        ++a;
        printf("%d\n", Print::a);
    }
}
int main() {
    Print tt[1000];
    return 0;
}
[7903] 行存储与列存储的效率问题！
******** 7-10 变量 ***********
[71001] 全局变量和静态变量有什么异同.
 answ : 全局变量(作用域是整个程序，作用域所有源文件，extern)
   全局变量，静态局部变量和静态全局变量 都在静态存储区分配空间。
[71003] C 与 C++ 变量初始化有什么不同？
 answ : C 只能用常数对全局变量和静态变量进行初始化。
   全局变量和静态变量的分配内存空间和初始化是在编译阶段完成。
  C++ file1 int a = 5;
  file2 extern int a; int b = a;编译阶段，b被初始化为0.执行阶段，
        在main被执行前有一个全局对象的构造过程。
  C++ 中全局对象，变量的构造函数调用顺序跟声明有关系.
[71203] 在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern "C".
  extern "C" float f(int a, char b); 这是告诉编译器 f() 是C连接的。不用赚了。
[71204] 两段代码共存于一个文件，编译时有选择地编译其中的一部分，如何实现？
 answ : (1) 在源码中使用条件编译语句，然后在程序文件中定义宏的形式来选择需要的编译代码。
        (2) 在源码中使用条件编译语句，然后在编译命令的命令中加入宏定义命令来实现选择编译
