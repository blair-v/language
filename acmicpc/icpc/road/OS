[OS] 第一章 引论
OS的主要作用
1，用户与硬件系统的接口  软件接口，给用户提供三种方式 
  (1)，命令方式
  (2)，系统调用方式 : OS 提供给用户一些 操作函数
  (3)，图形，窗口方式
2，计算机四类资源的管理者
  资源 ： 指的是硬件资源
   (1)，处理机管理  (为各个进程分配处理机。。。)
   (2)，存储器管理  (内存回收)
   (3)，设备管理    (I/O设备)
   (4)，文件管理    (文件的保护和共享)
 --------------------------------
  (1), 作业调度  外存 -> 内存 (选多个)
  (2), 进程调度  分配处理机 (选 1 个)
两种资源共享方式
（1）互斥共享方式   [如 ： 火车上的厕所] 打印机等硬件；栈、变量、表格等软件
（2）同时访问方式   [火车，教室] 多个进程同时访问的资源，如：磁盘、重入码写的文件。
操作系统两个最基本的特征：并发和共享
[OS] 第二章 进程管理
进程的基本概念 ： 程序在并发环境中的执行过程, 资源分配和独立运行的基本单位
 * 进程控制 *  * 进程同步 *  * 进程通信 *  * 线程 *
 进程的特征
   1, 结构特征  进程结构  PCB 进程控制块, 程序段, 数据段
   2, 动态性编译器会预先标记某些变量将来需要多大内存编译器会预先标记某些变编编译器会预先标记某些变量将来需要多大内存
比如你声明的一个数组编译器会预先标记某些变量将来需要多大内存
 进程的生命周期：进程由创建而产生，由调度而执行，由撤销而消亡的过程
 进程的三种基本状态 { 1, 就绪状态   2, 执行状态   3, 阻塞状态 }
  PCB 进程控制块 『 PCB是OS中最重要的记录型结构。OS用PCB对并发进程进行管理和控制。
                  PCB是进程存在的唯一标志。  PCB常驻内存。
                  OS专门开辟PCB区将所有的PCB组织成若干个链表或队列。 』
 PCB 中的信息 『 （1）进程标识符  （2）处理机状态  （3）进程调度信息  （4）进程控制信息  』
[OS] 第三章 处理机调度与死锁
 一个批处理型作业，从进入系统并驻留在外存的后备队列上开始，直至作业运行完毕，可能要经历的三级调度
 *高级调度*  *低级调度*  *中级调度*
堆和栈的区别 『
 1，管理方式不同 2，空间大小不同 3，能否产生碎片不同 4，生长方向不同 5， 分配方式不同 6， 分配效率不同 』
C编译的程序
 一个由C/C++编译的程序占用的内存分为以下几个部分 
   1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 
   2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。
   3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 
   4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
   5、程序代码区—存放函数体的二进制代码。
二.在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区
 1.栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。
 2.堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
 3.自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
 4.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
 5.常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）
 自由存储区  编译器会预先标记某些变量将来需要多大内存  是在自由存储区标记的？他将来来占多大内存
*** other 进程，线程 与 Linux虚存
*1，进程与线程与区别以及线程安全
   进程是并发的程序在执行过程中分配和管理资源的基本单位，是一个动态的概念，竞争计算机系统资源的基本单位。
   进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
   线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
    区别 ： 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，
            必须依存在应用程序中，由应用程序提供多个线程执行控制。
    区别 ： 操作系统并没有将多个线程看做多个独立的应用，来实现线程的调度和管理以及资源分配。
    区别 ： 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
*2，Linux操作系统采用了虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。
   该空间是块大小为4G的线性虚拟空间，利用虚拟地址不但能起到保护操作系统的效果(用户不能直接访问物理内存)，用户程序可使用比实际物理内存更大的地址空间
 (1) 4G 进程空间  = (0～3G)用户空间 + (3G~4G)内核空间
 (2) 用户空间对应进程，所以每当进程切换，用户空间就会跟着变化;而内核空间是由内核负责映射，
  它并不会跟着进程改变，是固定的。内核空间地址有自己对应的页表，用户进程各自有不同的页表。
 (3) 每个进程的用户空间都是完全独立，互不相干的。
第四章 存储器管理
存储层次至少分三级 ： CPU寄存器，主存，辅存。
                   细划分 ： 寄存器，高速缓存，主存储器，磁盘缓存，固定磁盘，可移动介质。
           寄存器与主存 被称为可执行存储器。
   进程可在很少的时钟周期内使用一条指令对可执行存储器进行访问。
   对辅存的访问需要通过I/O设备来实现，因此将涉及中断，设备驱动程序以及物理设备的运行所需时间相差三个数量级。
   CPU的控制部件只能从主存中取得指令和数据，数据能够从主存储器读取并将它们装入到寄存器中。
   或者从寄存器存入到主存储器。由于主存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛
   盾，在计算机系统中引入了寄存器和高速缓存(局部性原理)。
 磁盘缓存，并不是一种实际存在的物理介质，它依托于固定磁盘，提供对主存储器空间的扩充。
 4.2 程序的装入和链接
  要使程序运行，必须先为之创建进程。创建进程第一件事 ： 将程序与数据装入内存。
   源程序 --> 编译 (编译程序) --> 若干目标模块
  目标模块 --> 链接 (链接程序) --> 装入模块  --> （装入程序） --> 内存
 程序的装入 1，绝对装入方式 2，可重定位装入方式 3，动态运行时装入方式
 4.2.2 程序的链接 ：
   (1) 静态链接  (2) 装入时动态链接  (3) 运行时动态链接
 4.4, 分页 (512B~8KB)  4.5 分段 
 4.5.4 段页式 
   分页系统能有效的提高内存利用率，而分段系统能很好的满足用户需要。
    分段系统便于实现，分段可共享，易于保护，可动态链接等一系列优点。
    分页系统能很好的解决内存的外碎片问题，以及可为各个分段离散地分配内存等问题。
 4.6 虚拟存储器
    基于局部性原理，应用程序在运行之前，没有必要全部装入内存，仅须将那些当前要运
   行的少数页面或段装入内存便可运行，其余部分暂留在盘上。程序运行时，如果它所要访
   问的页(段)已调入内存，便可继续执行下去。但如果程序所要访问的页(段)尚未调入内存
   (称为缺页或缺段)，利用OS的请求调页(段)功能，将它们调入内存，以使进程能继续执行
   下去。如果内存满，则置换功能。
   虚拟存储器具有请求调入功能和置换功能。
   	
   
                   

